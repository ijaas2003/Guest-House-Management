{"ast":null,"code":"import _slicedToArray from \"C:/NewPrac/Prac/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { base64Decode, base64Encode } from '../encoding/base64';\nimport { md5 } from '../encoding/md5';\nimport { LICENSE_STATUS } from '../utils/licenseStatus';\nimport { LICENSE_SCOPES } from '../utils/licenseScope';\nimport { LICENSING_MODELS } from '../utils/licensingModel';\nvar getDefaultReleaseDate = function getDefaultReleaseDate() {\n  var today = new Date();\n  today.setHours(0, 0, 0, 0);\n  return today;\n};\nexport function generateReleaseInfo() {\n  var releaseDate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getDefaultReleaseDate();\n  return base64Encode(releaseDate.getTime().toString());\n}\nvar expiryReg = /^.*EXPIRY=([0-9]+),.*$/;\n/**\n * Format: ORDER:${orderNumber},EXPIRY=${expiryTimestamp},KEYVERSION=1\n */\nvar decodeLicenseVersion1 = function decodeLicenseVersion1(license) {\n  var expiryTimestamp;\n  try {\n    expiryTimestamp = parseInt(license.match(expiryReg)[1], 10);\n    if (!expiryTimestamp || Number.isNaN(expiryTimestamp)) {\n      expiryTimestamp = null;\n    }\n  } catch (err) {\n    expiryTimestamp = null;\n  }\n  return {\n    scope: 'pro',\n    licensingModel: 'perpetual',\n    expiryTimestamp: expiryTimestamp\n  };\n};\n\n/**\n * Format: O=${orderNumber},E=${expiryTimestamp},S=${scope},LM=${licensingModel},KV=2`;\n */\nvar decodeLicenseVersion2 = function decodeLicenseVersion2(license) {\n  var licenseInfo = {\n    scope: null,\n    licensingModel: null,\n    expiryTimestamp: null\n  };\n  license.split(',').map(function (token) {\n    return token.split('=');\n  }).filter(function (el) {\n    return el.length === 2;\n  }).forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      key = _ref2[0],\n      value = _ref2[1];\n    if (key === 'S') {\n      licenseInfo.scope = value;\n    }\n    if (key === 'LM') {\n      licenseInfo.licensingModel = value;\n    }\n    if (key === 'E') {\n      var expiryTimestamp = parseInt(value, 10);\n      if (expiryTimestamp && !Number.isNaN(expiryTimestamp)) {\n        licenseInfo.expiryTimestamp = expiryTimestamp;\n      }\n    }\n  });\n  return licenseInfo;\n};\n\n/**\n * Decode the license based on its key version and return a version-agnostic `MuiLicense` object.\n */\nvar decodeLicense = function decodeLicense(encodedLicense) {\n  var license = base64Decode(encodedLicense);\n  if (license.includes('KEYVERSION=1')) {\n    return decodeLicenseVersion1(license);\n  }\n  if (license.includes('KV=2')) {\n    return decodeLicenseVersion2(license);\n  }\n  return null;\n};\nexport function verifyLicense(_ref3) {\n  var releaseInfo = _ref3.releaseInfo,\n    licenseKey = _ref3.licenseKey,\n    acceptedScopes = _ref3.acceptedScopes;\n  if (!releaseInfo) {\n    throw new Error('MUI: The release information is missing. Not able to validate license.');\n  }\n  if (!licenseKey) {\n    return {\n      status: LICENSE_STATUS.NotFound\n    };\n  }\n  var hash = licenseKey.substr(0, 32);\n  var encoded = licenseKey.substr(32);\n  if (hash !== md5(encoded)) {\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  var license = decodeLicense(encoded);\n  if (license == null) {\n    console.error('Error checking license. Key version not found!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  if (license.licensingModel == null || !LICENSING_MODELS.includes(license.licensingModel)) {\n    console.error('Error checking license. Licensing model not found or invalid!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  if (license.expiryTimestamp == null) {\n    console.error('Error checking license. Expiry timestamp not found or invalid!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  if (license.licensingModel === 'perpetual' || process.env.NODE_ENV === 'production') {\n    var pkgTimestamp = parseInt(base64Decode(releaseInfo), 10);\n    if (Number.isNaN(pkgTimestamp)) {\n      throw new Error('MUI: The release information is invalid. Not able to validate license.');\n    }\n    if (license.expiryTimestamp < pkgTimestamp) {\n      return {\n        status: LICENSE_STATUS.ExpiredVersion\n      };\n    }\n  } else if (license.licensingModel === 'subscription' || license.licensingModel === 'annual') {\n    if (new Date().getTime() > license.expiryTimestamp) {\n      if (\n      // 30 days grace\n      new Date().getTime() < license.expiryTimestamp + 1000 * 3600 * 24 * 30 || process.env.NODE_ENV !== 'development') {\n        return {\n          status: LICENSE_STATUS.ExpiredAnnualGrace,\n          meta: {\n            expiryTimestamp: license.expiryTimestamp,\n            licenseKey: licenseKey\n          }\n        };\n      }\n      return {\n        status: LICENSE_STATUS.ExpiredAnnual,\n        meta: {\n          expiryTimestamp: license.expiryTimestamp,\n          licenseKey: licenseKey\n        }\n      };\n    }\n  }\n  if (license.scope == null || !LICENSE_SCOPES.includes(license.scope)) {\n    console.error('Error checking license. scope not found or invalid!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  if (!acceptedScopes.includes(license.scope)) {\n    return {\n      status: LICENSE_STATUS.OutOfScope\n    };\n  }\n  return {\n    status: LICENSE_STATUS.Valid\n  };\n}","map":{"version":3,"names":["base64Decode","base64Encode","md5","LICENSE_STATUS","LICENSE_SCOPES","LICENSING_MODELS","getDefaultReleaseDate","today","Date","setHours","generateReleaseInfo","releaseDate","arguments","length","undefined","getTime","toString","expiryReg","decodeLicenseVersion1","license","expiryTimestamp","parseInt","match","Number","isNaN","err","scope","licensingModel","decodeLicenseVersion2","licenseInfo","split","map","token","filter","el","forEach","_ref","_ref2","_slicedToArray","key","value","decodeLicense","encodedLicense","includes","verifyLicense","_ref3","releaseInfo","licenseKey","acceptedScopes","Error","status","NotFound","hash","substr","encoded","Invalid","console","error","process","env","NODE_ENV","pkgTimestamp","ExpiredVersion","ExpiredAnnualGrace","meta","ExpiredAnnual","OutOfScope","Valid"],"sources":["C:/NewPrac/Prac/client/node_modules/@mui/x-license-pro/verifyLicense/verifyLicense.js"],"sourcesContent":["import { base64Decode, base64Encode } from '../encoding/base64';\nimport { md5 } from '../encoding/md5';\nimport { LICENSE_STATUS } from '../utils/licenseStatus';\nimport { LICENSE_SCOPES } from '../utils/licenseScope';\nimport { LICENSING_MODELS } from '../utils/licensingModel';\nconst getDefaultReleaseDate = () => {\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n  return today;\n};\nexport function generateReleaseInfo(releaseDate = getDefaultReleaseDate()) {\n  return base64Encode(releaseDate.getTime().toString());\n}\nconst expiryReg = /^.*EXPIRY=([0-9]+),.*$/;\n/**\n * Format: ORDER:${orderNumber},EXPIRY=${expiryTimestamp},KEYVERSION=1\n */\nconst decodeLicenseVersion1 = license => {\n  let expiryTimestamp;\n  try {\n    expiryTimestamp = parseInt(license.match(expiryReg)[1], 10);\n    if (!expiryTimestamp || Number.isNaN(expiryTimestamp)) {\n      expiryTimestamp = null;\n    }\n  } catch (err) {\n    expiryTimestamp = null;\n  }\n  return {\n    scope: 'pro',\n    licensingModel: 'perpetual',\n    expiryTimestamp\n  };\n};\n\n/**\n * Format: O=${orderNumber},E=${expiryTimestamp},S=${scope},LM=${licensingModel},KV=2`;\n */\nconst decodeLicenseVersion2 = license => {\n  const licenseInfo = {\n    scope: null,\n    licensingModel: null,\n    expiryTimestamp: null\n  };\n  license.split(',').map(token => token.split('=')).filter(el => el.length === 2).forEach(([key, value]) => {\n    if (key === 'S') {\n      licenseInfo.scope = value;\n    }\n    if (key === 'LM') {\n      licenseInfo.licensingModel = value;\n    }\n    if (key === 'E') {\n      const expiryTimestamp = parseInt(value, 10);\n      if (expiryTimestamp && !Number.isNaN(expiryTimestamp)) {\n        licenseInfo.expiryTimestamp = expiryTimestamp;\n      }\n    }\n  });\n  return licenseInfo;\n};\n\n/**\n * Decode the license based on its key version and return a version-agnostic `MuiLicense` object.\n */\nconst decodeLicense = encodedLicense => {\n  const license = base64Decode(encodedLicense);\n  if (license.includes('KEYVERSION=1')) {\n    return decodeLicenseVersion1(license);\n  }\n  if (license.includes('KV=2')) {\n    return decodeLicenseVersion2(license);\n  }\n  return null;\n};\nexport function verifyLicense({\n  releaseInfo,\n  licenseKey,\n  acceptedScopes\n}) {\n  if (!releaseInfo) {\n    throw new Error('MUI: The release information is missing. Not able to validate license.');\n  }\n  if (!licenseKey) {\n    return {\n      status: LICENSE_STATUS.NotFound\n    };\n  }\n  const hash = licenseKey.substr(0, 32);\n  const encoded = licenseKey.substr(32);\n  if (hash !== md5(encoded)) {\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  const license = decodeLicense(encoded);\n  if (license == null) {\n    console.error('Error checking license. Key version not found!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  if (license.licensingModel == null || !LICENSING_MODELS.includes(license.licensingModel)) {\n    console.error('Error checking license. Licensing model not found or invalid!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  if (license.expiryTimestamp == null) {\n    console.error('Error checking license. Expiry timestamp not found or invalid!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  if (license.licensingModel === 'perpetual' || process.env.NODE_ENV === 'production') {\n    const pkgTimestamp = parseInt(base64Decode(releaseInfo), 10);\n    if (Number.isNaN(pkgTimestamp)) {\n      throw new Error('MUI: The release information is invalid. Not able to validate license.');\n    }\n    if (license.expiryTimestamp < pkgTimestamp) {\n      return {\n        status: LICENSE_STATUS.ExpiredVersion\n      };\n    }\n  } else if (license.licensingModel === 'subscription' || license.licensingModel === 'annual') {\n    if (new Date().getTime() > license.expiryTimestamp) {\n      if (\n      // 30 days grace\n      new Date().getTime() < license.expiryTimestamp + 1000 * 3600 * 24 * 30 || process.env.NODE_ENV !== 'development') {\n        return {\n          status: LICENSE_STATUS.ExpiredAnnualGrace,\n          meta: {\n            expiryTimestamp: license.expiryTimestamp,\n            licenseKey\n          }\n        };\n      }\n      return {\n        status: LICENSE_STATUS.ExpiredAnnual,\n        meta: {\n          expiryTimestamp: license.expiryTimestamp,\n          licenseKey\n        }\n      };\n    }\n  }\n  if (license.scope == null || !LICENSE_SCOPES.includes(license.scope)) {\n    console.error('Error checking license. scope not found or invalid!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  if (!acceptedScopes.includes(license.scope)) {\n    return {\n      status: LICENSE_STATUS.OutOfScope\n    };\n  }\n  return {\n    status: LICENSE_STATUS.Valid\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}